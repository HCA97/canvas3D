<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Suzanne monkey 3D HTML5 canvas realization</title>

<script type="text/javascript">
  function color(r, g, b, a)
  {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;

    this.lightnessMap = [];
  }
  color.prototype.lightness = function(lightnessK)
  {
    var min = Math.min(this.r, this.g, this.b);
    var max = Math.max(this.r, this.g, this.b);
    
    var lightnessMapIndex = Math.round(lightnessK * 255);
    if(this.lightnessMap[lightnessMapIndex])
      return this.lightnessMap[lightnessMapIndex];

    // Simple processing gray colors
    if(min == max)
    {
      return this.lightnessMap[lightnessMapIndex] = new color(this.r * lightnessK, this.g * lightnessK, this.b * lightnessK, this.a);
    }

    // Convert to HSL
    var H;
    var S;
    var L = (min + max) / 2 / 255;
    
    if(max == this.r && this.g >= this.b)
      H = 60 * (this.g - this.b) / (max - min) + 0;
    else if(max == this.r)
      H = 60 * (this.g - this.b) / (max - min) + 360;
    else if(max == this.g)
      H = 60 * (this.b - this.r) / (max - min) + 120;
    else if(max == this.b)
      H = 60 * (this.r - this.g) / (max - min) + 240;
    H = H % 360;

    if(L == 0 || max == min)
      S = 0;
    else if(L <= 0.5)
      S = (max - min) / (2 * L) / 255;
    else if(L < 1)
      S = (max - min) / (2 - 2*L) / 255;
    else if(L == 1)
      S = 1;

    // Apply lightness
    L = L * lightnessK;

    // Convert to RGB
    if(L <= 0.5)
      var Q = L * (1 + S);
    else
      var Q = L  + S - (L * S);

    var P = 2 * L - Q;
    var Hk = H / 360;

    var Tr = Hk + 1/3; if(Tr < 0) Tr = Tr + 1;
    var Tg = Hk;
    var Tb = Hk - 1/3; if(Tr > 1) Tr = Tr - 1;

    if(Tr < 1/6)
      var r = P + ((Q - P) * 6 * Tr);
    else if(Tr < 1/2)
      var r = Q;
    else if(Tr < 2/3)
      var r = P + ((Q - P) * 6 * (2/3 - Tr));
    else
      var r = P;

    if(Tg < 1/6)
      var g = P + ((Q - P) * 6 * Tg);
    else if(Tg < 1/2)
      var g = Q;
    else if(Tg < 2/3)
      var g = P + ((Q - P) * 6 * (2/3 - Tg));
    else
      var g = P;

    if(Tb < 1/6)
      var b = P + ((Q - P) * 6 * Tb);
    else if(Tb < 1/2)
      var b = Q;
    else if(Tb < 2/3)
      var b = P + ((Q - P) * 6 * (2/3 - Tb));
    else
      var b = P;

    return this.lightnessMap[lightnessMapIndex] = new color(Math.round(r*255), Math.round(g*255), Math.round(b*255), this.a);
  }

  function point2D(x, y)
  {
    this.x = x;
    this.y = y;
  }
  point2D.prototype.move = function(p2D)
  {
    this.x += p2D.x;
    this.y += p2D.y;
  }

  function point3D(x, y, z)
  {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  point3D.prototype.move = function(p3D)
  {
    this.x += p3D.x;
    this.y += p3D.y;
    this.z += p3D.z;
  }
  point3D.prototype.swap = function(p3D)
  {
    this.x = p3D.x;
    this.y = p3D.y;
    this.z = p3D.z;
  }
  point3D.prototype.rotate = function(axis, angleGr)
  {
    angleRad = angleGr * Math.PI / 180;
    switch (axis)
    {
      case "x":
      {
	var tempPoint = new point3D(
	  this.x,
	  this.y * Math.cos(angleRad) - this.z * Math.sin(angleRad),
	  this.y * Math.sin(angleRad) + this.z * Math.cos(angleRad)
	  );
	this.swap(tempPoint);
	break;
      } 
      case "y":
      {
	var tempPoint = new point3D(
	  this.x * Math.cos(angleRad) + this.z * Math.sin(angleRad),
	  this.y,
	 -this.x * Math.sin(angleRad) + this.z * Math.cos(angleRad)
	  );
	this.swap(tempPoint);
	break;
      } 
      case "z":
      {
	var tempPoint = new point3D(
	  this.x * Math.cos(angleRad) - this.y * Math.sin(angleRad),
	  this.x * Math.sin(angleRad) + this.y * Math.cos(angleRad),
	  this.z
	  );
	this.swap(tempPoint);
	break;
      } 
    }
  }


  function poly()
  {
    var normal = arguments[0];

    var z = 0;
    var points = [];
    for(var i = 1; i < arguments.length; i++)
    {
      points.push(arguments[i]);
      z += arguments[i].z;
    }
    z /= arguments.length;

    this.points = points;
    this.z = z;

    // Calculating normal
    var v1 = new point3D(points[2].x - points[1].x, points[2].y - points[1].y, points[2].z - points[1].z);
    var v2 = new point3D(points[0].x - points[1].x, points[0].y - points[1].y, points[0].z - points[1].z);

    if(normal === null)
    {
      var normal = new point3D(v1.y*v2.z-v2.y*v1.z, v1.z*v2.x-v2.z*v1.x, v1.x*v2.y-v2.x*v1.y);
      var normalLen = Math.sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
      normal.x /= normalLen;
      normal.y /= normalLen;
      normal.z /= normalLen;
    }

    this.normal = normal;
  }
  poly.prototype.move = function(p3D)
  {
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      point.move(p3D);
    }
    this.recalculateZ();
  }
  poly.prototype.rotate = function(axis, angle)
  {
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      point.rotate(axis, angle);
    }
    
    this.normal.rotate(axis, angle);
    this.recalculateZ();
  }
  poly.prototype.put = function(center, fillColor, edgeColor)
  {
    // Calulate visibility
    var normalAngleRad = Math.acos(this.normal.z);
    if(normalAngleRad / Math.PI * 180 >= 90)
      return;

    var lightIntensity = 1 - 2 * (normalAngleRad / Math.PI);	// Convert RAD -> GRAD
    var newColor = fillColor.lightness(lightIntensity);

    ctx.fillStyle = 'rgba('+newColor.r+','+newColor.g+','+newColor.b+','+newColor.a+')';
    ctx.beginPath();
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      if(i)
	ctx.lineTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
      else
	ctx.moveTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
    }
    ctx.fill();

    ctx.lineWidth = 1;
    var newColor = edgeColor.lightness(lightIntensity);
    ctx.strokeStyle = 'rgba('+newColor.r+','+newColor.g+','+newColor.b+','+newColor.a+')';
    ctx.beginPath();
    var point = this.points[this.points.length-1];
    ctx.moveTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      ctx.lineTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
    }
    ctx.stroke();
  }
  poly.prototype.recalculateZ = function()
  {
    var z;
    for(var i = 0; i < this.points.length; i++)
    {
      z += this.points[i].z;
    }
    z /= this.points.length;

    this.z = z;
  }

  function Model(polys, points, fillColor, edgeColor)
  {
    this.polys = polys;
    this.points = points;
    this.fillColor = fillColor;
    this.edgeColor = edgeColor;

    // Add normals
    for(var i = 0; i < polys.length; i++)
    {
      this.points.push(polys[i].normal);
    }
  }

  function move(o3D, p3D)
  {    
    for(var i = 0; i < o3D.points.length - o3D.polys.length; i++)
    {
      var point = o3D.points[i];
      point.move(p3D);
    }
  }
  function put(o3D, center)
  {
    var zSorting = [];
    for(var i = 0; i < o3D.polys.length; i++)
    {
      var poly = o3D.polys[i];
      zSorting.push(poly.z);
    }
    zSorting.sort();
    var lastZ;
    for(var i = 0; i < zSorting.length; i++)
    {
      if(lastZ == zSorting[i])
	continue;
      lastZ = zSorting[i];

      for(var j = 0; j < o3D.polys.length; j++)
      {
	var poly = o3D.polys[j];
	if(poly.z != zSorting[i])
	  continue;
	poly.put(center, o3D.fillColor, o3D.edgeColor);
      }
    }
  }
  function rotate(o3D, axis, angle)
  {
    for(var i = 0; i < o3D.points.length; i++)
    {
      var point = o3D.points[i];
      point.rotate(axis, angle);
    }
  }

  function nextFrame()
  {
    ctx.fillStyle = 'rgba(0, 0, 0, 1)';  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  // clear canvas

    rotate(model, 'y', 0.6);

    ctx.fillStyle = 'rgba(50, 50, 200, 1)';
    ctx.strokeStyle = 'rgba(60, 60, 210, 1)';
    put(model, centerScreen);

    // FPS calculation
    if(!fpslastUpdate) 
    {
      fpslastUpdate = Date.now();
    }
    else
    {
      var now = Date.now();
      fps.unshift(1000 / (now - fpslastUpdate));
      fpslastUpdate = now;
    }
    if(fps.length >= fpsFilter)
    {
      var fpsValue = 0.0;
      for(var i = 0; i < fpsFilter; i++)
	fpsValue += fps[i];

      ctx.fillStyle = "white";
      ctx.fillText("" + Math.floor(fpsValue/fpsFilter) + " fps", 10, 20);
    }
    if(fps.length >= fpsFilter * 8)
    {
      fps = fps.slice(0, fpsFilter);
    }
  }

  function processReqChange()
  {
    try {
      if (req.readyState == 4) {
	if (req.status == 200) {
	  model = ply_reader(req.responseText);
	  
	  var divinfo = document.getElementById('fileinfo');
	  divinfo.innerHTML = "File: "+PLYFile+", polygons: "+model.polys.length+", points: "+model.points.length;
	  //move(model, new point3D(-50,-50,-50));
	  rotate(model, 'y', 180);

	  put(model, centerScreen);

	} else {
	    alert("Cannot get 3D data:\n" + req.statusText);
	}
      }
    }
    catch (e) {
      alert(e+' line: ' + e.lineNumber);
    }
  }

  function ply_reader(data)
  {
    var model;
    var scaleFactor = 100;
    var hasNormal = false;

    // Read header
    while(data.length)
    {
      var retval = data.match(/.*/);
      var str = retval[0];
      data = data.substr(str.length+1);

      var retval = str.match(/element (\w+) (\d+)/);
      if(retval)
      {
	if(retval[1] == "vertex")
	  var npoints = parseInt(retval[2]);
	if(retval[1] == "face")
	  var npolys = parseInt(retval[2]);
      }
      if(str == "property float nx")
	hasNormal = true;

      if(str == "end_header")
	break;
    }

    // Read points
    var points = [];
    var normals = [];
    for (var i = 0; i < npoints; i++) 
    {
      var retval = data.match(/([\d.-]+ ?)+/);
      var str = retval[0];
      data = data.substr(str.length+1);

      var retval = str.match(/([\d.-]+)/g);
      var point = new point3D(parseFloat(retval[0])*scaleFactor, parseFloat(retval[1])*scaleFactor, parseFloat(retval[2])*scaleFactor);
      points.push(point);
      if(hasNormal)
      {
	var normal = new point3D(parseFloat(retval[3]), parseFloat(retval[4]), parseFloat(retval[5]));
	normals.push(normal);
      }
    }

    // Polygons
    var polys = [];
    for (var i = 0; i < npolys; i++) 
    {
      var retval = data.match(/(\d+ ?)+/);
      var str = retval[0];
      data = data.substr(str.length+1);
      
      var retval = str.match(/(\d+)/g);

      var newPolyString = "new poly(";
      newPolyString += hasNormal ? "normals["+retval[1]+"]," : "null,";

      for (var j = 0; j < retval.length; j++) 
      {
	retval[j] = parseInt(retval[j]);
	if(j >= 2)
	  newPolyString += ",";
	if(j)
	  newPolyString += "points["+retval[j]+"]";
      }
      newPolyString += ");";
      
      polys.push(eval(newPolyString));
    }

    // Create model
    model = new Model(polys, points, new color(50,200,50,1), new color(60,210,60,1));

    return model;
  }

  
  var PLYFile = 'monkey.ply';
  var fpsWanted = 24;
  var fps = [], fpslastUpdate;
  var fpsFilter = fpsWanted*2;
  function init(){
    canvas = document.getElementById('canvas');
    if (canvas.getContext){
      ctx = canvas.getContext('2d');

      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height); // clear canvas

      centerScreen = new point2D(canvas.width / 2, canvas.height / 2);
      
      try {
	req = new XMLHttpRequest();
      } catch (e) {
	alert("Unsupported browser:\n"+e);
      }
      if (req) {       
	req.open("GET", PLYFile, true);
	req.onreadystatechange = processReqChange;
	req.send(null);
      }
    }
  }
</script>

<style type="text/css">
  canvas { border: 0px solid black; }
</style>

</head>


<body onload="init();">

<h1>Suzanne monkey 3D HTML5 canvas realization on 2D contex</h1>
<p>Features:
  <ul>
    <li>3D moving object</li>
    <li>3D rotating</li>
    <li>Direct illumination</li>
    <li>Highlighting edges</li>
    <li>Skip processing for invisible polygons</li>
    <li>Optimization processing for points</li>
    <li>Z-sorting for polygons</li>
  </ul>
</p>
<canvas id="canvas" width="400" height="225"></canvas>
<br>
<div id="fileinfo"></div>
<br>
<button onclick="timer = setInterval(nextFrame, 1000 / fpsWanted);">Start Y rotating</button> <button onclick="if(timer) clearInterval(timer);">Stop Y rotating</button>
</body>

</html>

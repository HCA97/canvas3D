<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Utah teapot 3D HTML5 canvas realization</title>

<script type="text/javascript">
  function color(r, g, b, a)
  {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  function point2D(x, y)
  {
    this.x = x;
    this.y = y;
  }
  point2D.prototype.move = function(p2D)
  {
    this.x += p2D.x;
    this.y += p2D.y;
  }

  function point3D(x, y, z)
  {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  point3D.prototype.move = function(p3D)
  {
    this.x += p3D.x;
    this.y += p3D.y;
    this.z += p3D.z;
  }
  point3D.prototype.swap = function(p3D)
  {
    this.x = p3D.x;
    this.y = p3D.y;
    this.z = p3D.z;
  }
  point3D.prototype.rotate = function(axis, angleGr)
  {
    angleRad = angleGr * Math.PI / 180;
    switch (axis)
    {
      case "x":
      {
	var tempPoint = new point3D(
	  this.x,
	  this.y * Math.cos(angleRad) - this.z * Math.sin(angleRad),
	  this.y * Math.sin(angleRad) + this.z * Math.cos(angleRad)
	  );
	this.swap(tempPoint);
	break;
      } 
      case "y":
      {
	var tempPoint = new point3D(
	  this.x * Math.cos(angleRad) + this.z * Math.sin(angleRad),
	  this.y,
	 -this.x * Math.sin(angleRad) + this.z * Math.cos(angleRad)
	  );
	this.swap(tempPoint);
	break;
      } 
      case "z":
      {
	var tempPoint = new point3D(
	  this.x * Math.cos(angleRad) - this.y * Math.sin(angleRad),
	  this.x * Math.sin(angleRad) + this.y * Math.cos(angleRad),
	  this.z
	  );
	this.swap(tempPoint);
	break;
      } 
    }
  }

  function normal3D(p3D, length)
  {
    this.point = p3D;
    this.length = length;
  }

  function poly()
  {
    var points = [];
    for(var i = 0; i < arguments.length; i++)
      points.push(arguments[i]);

    this.points = points;

    // Calculating normal
    var v1 = new point3D(points[2].x - points[1].x, points[2].y - points[1].y, points[2].z - points[1].z);
    var v2 = new point3D(points[0].x - points[1].x, points[0].y - points[1].y, points[0].z - points[1].z);

    var normalP3D = new point3D(v1.y*v2.z-v2.y*v1.z, v1.z*v2.x-v2.z*v1.x, v1.x*v2.y-v2.x*v1.y);
    var normalLen = Math.sqrt(normalP3D.x*normalP3D.x + normalP3D.y*normalP3D.y + normalP3D.z*normalP3D.z);

    this.normal = new normal3D(normalP3D, normalLen);
  }
  poly.prototype.move = function(p3D)
  {
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      point.move(p3D);
    }
  }
  poly.prototype.rotate = function(axis, angle)
  {
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      point.rotate(axis, angle);
    }
    
    this.normal.point.rotate(axis, angle);
  }
  poly.prototype.put = function(center, fillColor, edgeColor)
  {
    // Calulate visibility
    var normalAngleRad = Math.acos(this.normal.point.z/this.normal.length);
    if(normalAngleRad / Math.PI * 180 >= 90)
      return;

    var lightIntensity = 1 - 2 * (normalAngleRad / Math.PI);

    ctx.fillStyle = 'rgba('+fillColor.r+','+fillColor.g+','+fillColor.b+','+(fillColor.a*lightIntensity)+')';
    ctx.beginPath();
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      if(i)
	ctx.lineTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
      else
	ctx.moveTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
    }
    ctx.fill();

    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba('+edgeColor.r+','+edgeColor.g+','+edgeColor.b+','+(edgeColor.a*lightIntensity)+')';
    ctx.beginPath();
    var point = this.points[this.points.length-1];
    ctx.moveTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
    for(var i = 0; i < this.points.length; i++)
    {
      var point = this.points[i];
      ctx.lineTo(center.x + parseInt(point.x), center.y - parseInt(point.y));
    }
    ctx.stroke();
  }

  function Model(patches, points, fillColor, edgeColor)
  {
    this.points = points;
    this.fillColor = fillColor;
    this.edgeColor = edgeColor;

    var polys = [];
    for(var i = 0; i < patches.length; i++)
    {
      var patch = patches[i];
      polys.push(new poly(
	points[patch[0]],points[patch[1]],points[patch[2]],points[patch[3]],
	points[patch[4]],points[patch[5]],points[patch[6]],points[patch[7]],
	points[patch[8]],points[patch[9]],points[patch[10]],points[patch[11]],
	points[patch[12]],points[patch[13]],points[patch[14]],points[patch[15]]
	));
    }
    this.polys = polys;

    // Add normals
    for(var i = 0; i < polys.length; i++)
    {
      this.points.push(polys[i].normal.point);
    }
  }

  function move(o3D, p3D)
  {    
    for(var i = 0; i < o3D.points.length - o3D.polys.length; i++)
    {
      var point = o3D.points[i];
      point.move(p3D);
    }
  }
  function put(o3D, center)
  {
    for(var i = 0; i < o3D.polys.length; i++)
    {
      var poly = o3D.polys[i];
      poly.put(center, o3D.fillColor, o3D.edgeColor);
    }
  }
  function rotate(o3D, axis, angle)
  {
    for(var i = 0; i < o3D.points.length; i++)
    {
      var point = o3D.points[i];
      point.rotate(axis, angle);
    }
  }

  var req;
  function init(){
    canvas = document.getElementById('3Dcube');
    if (canvas.getContext){
      ctx = canvas.getContext('2d');

      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height); // clear canvas

      centerScreen = new point2D(canvas.width / 2, canvas.height / 2);
      
      try {
	req = new XMLHttpRequest();
      } catch (e) {
	alert("Unsupported browser:\n"+e);
      }
      if (req) {       
	req.open("GET", 'teapot.data', true);
	req.onreadystatechange = processReqChange;
	req.send(null);
      }
    }
  }

  function nextFrame()
  {
    ctx.fillStyle = 'rgba(0, 0, 0, 1)';  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  // clear canvas

    rotate(cube, 'x', 0.4);
    rotate(cube, 'y', 0.6);
    rotate(cube, 'z', 0.3);

    ctx.fillStyle = 'rgba(50, 50, 200, 1)';
    ctx.strokeStyle = 'rgba(60, 60, 210, 1)';
    put(cube, centerScreen);
  }

  function processReqChange()
  {
    try {
      if (req.readyState == 4) {
	if (req.status == 200) {
	  var data = req.responseText;

	  // Patches
	  var retval = data.match(/\d+/);
	  var str = retval[0];
	  data = data.substr(str.length+1);
	  var npatches = parseInt(str);
	  var patches = [];

	  for (var i = 0; i < npatches; i++) 
	  {
	    var retval = data.match(/(\d+,?)+/);
	    var str = retval[0];
	    data = data.substr(str.length+1);

	    var retval = str.match(/(\d+)/g);
	    for (var j = 0; j < retval.length; j++) 
	    {
	      retval[j] = parseInt(retval[j]) - 1;
	    }
	    patches.push(retval);
	  }

	  // Points
	  var retval = data.match(/\d+/);
	  var str = retval[0];
	  data = data.substr(str.length+1);
	  var npoints = parseInt(str);
	  var points = [];

	  for (var i = 0; i < npoints; i++) 
	  {
	    var retval = data.match(/([\d.-]+,?)+/);
	    var str = retval[0];
	    data = data.substr(str.length+1);

	    var retval = str.match(/([\d.-]+)/g);
	    var point = new point3D(parseFloat(retval[0])*50, parseFloat(retval[1])*50, parseFloat(retval[2])*50);
	    points.push(point);
	  }

	  // Create model
	  model = new Model(patches, points, new color(50,50,200,1), new color(60,60,210,1));
  //rotate(model, 'x', 45);
  //rotate(model, 'y', 45);
	  put(model, centerScreen);

	  /*
	  cube = new Cube(100, new color(50,50,200,1), new color(60,60,210,1));
	  move(cube, new point3D(-50,-50,-50));
	  
	  rotate(cube, 'y', 45);
	  rotate(cube, 'z', 45);
	  
	  
	  put(cube, centerScreen);

	  timer = setInterval(nextFrame, 1000 / 60);

	  */
	} else {
	    alert("Cannot get 3D data:\n" + req.statusText);
	}
      }
    }
    catch (e) {
    }
  }
</script>

<style type="text/css">
  canvas { border: 0px solid black; }
</style>

</head>


<body onload="init();">

<h1>Utah teapot 3D HTML5 canvas realization on 2D contex</h1>
<p>Features:
  <ul>
    <li>3D moving object</li>
    <li>3D rotating</li>
    <li>Direct illumination</li>
    <li>Highlighting edges</li>
    <li>Skip processing for invisible polygons</li>
    <li>Optimization processing for points</li>
  </ul>
</p>
<canvas id="3Dcube" width="400" height="225"></canvas>

</body>

</html>

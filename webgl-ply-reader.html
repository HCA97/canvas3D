<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>PLY 3D model viewer based on HTML5 canvas</title>

<script src="sylvester.src.js" type="text/javascript"></script>
<script src="glUtils.js" type="text/javascript"></script>
<script src="webgl-ply-reader.js" type="text/javascript"></script>

<script type="text/javascript">
  function point3D(x, y, z)
  {
    this.x = x;
    this.y = y;
    this.z = z;
  }


  function Model(polys, vertices)
  {
    this.polys = polys;
    this.vertices = vertices;

    // Create a buffer for the cube's vertices.
    modelVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, modelVerticesBuffer);    
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);


    // Now set up the colors for the faces. We'll use solid colors
    // for each face.
    var color = [1.0*220/255,  1.0*220/255,  1.0*220/255,  1.0];
    // Convert the array of colors into a table for all the vertices.
    var generatedColors = [];
    for (i = 0; i < polys.length; i++) {
	generatedColors = generatedColors.concat(color);
    }
    modelVerticesColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, modelVerticesColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW);


    // Build the element array buffer; this specifies the indices
    // into the vertex array for each face's vertices.
    modelVerticesIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, modelVerticesIndexBuffer);
    // Now send the element array to GL
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(polys), gl.STATIC_DRAW);
  }


  function nextFrame()
  {
    ctx.fillStyle = 'rgba(0, 0, 0, 1)';  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  // clear canvas

    model.rotate('y', 0.6 * Math.PI / 180);

    ctx.fillStyle = 'rgba(50, 50, 200, 1)';
    ctx.strokeStyle = 'rgba(60, 60, 210, 1)';
    var visiblePolygons = model.put(centerScreen);

    // FPS calculation
    if(!fpslastUpdate) 
    {
      fpslastUpdate = Date.now();
    }
    else
    {
      var now = Date.now();
      fps.push(1000 / (now - fpslastUpdate));
      fpslastUpdate = now;
    }
    if(fps.length >= fpsFilter)
    {
      var fpsValue = 0.0;
      for(var i = fps.length - fpsFilter; i < fps.length; i++)
	fpsValue += fps[i];

      ctx.fillStyle = "white";
      ctx.fillText("" + Math.floor(fpsValue/fpsFilter) + " fps, "+visiblePolygons+" visible polygons, "+Math.round(visiblePolygons*fpsValue/fpsFilter)+" polygons per sec", 8, 16);
    }
    if(fps.length >= fpsFilter * 8)
    {
      fps = fps.slice(fps.length - fpsFilter);
    }
  }

  function processReqChange()
  {
    try {
      if (req.readyState == 4) {
	if (req.status == 200) {
	  initAfterGettingModel(req.responseText)
	} else {
	    alert("Cannot get 3D data:\n" + req.statusText);
	}
      }
    }
    catch (e) {
      alert(e+' line: ' + e.lineNumber);
    }
  }

  function ply_reader(data)
  {
    var hasNormal = false;

    // Read header
    while(data.length)
    {
      var retval = data.match(/.*/);
      var str = retval[0];
      data = data.substr(str.length+1);

      var retval = str.match(/element (\w+) (\d+)/);
      if(retval)
      {
	if(retval[1] == "vertex")
	  var npoints = parseInt(retval[2]);
	if(retval[1] == "face")
	  var npolys = parseInt(retval[2]);
      }
      if(str == "property float nx")
	hasNormal = true;

      if(str == "end_header")
	break;
    }

    // Read points
    var minPoint = new point3D(Infinity, Infinity, Infinity);
    var maxPoint = new point3D(-Infinity, -Infinity, -Infinity);
    var vertices = [];
    for (var i = 0; i < npoints; i++) 
    {
      var retval = data.match(/([\d.-]+ ?)+/);
      var str = retval[0];
      data = data.substr(str.length+1);

      var retval = str.match(/([\d.-]+)/g);
      var point = new point3D(parseFloat(retval[0]), parseFloat(retval[1]), parseFloat(retval[2]));
      vertices.push(point.x, point.y, point.z);

      minPoint.x = Math.min(minPoint.x, point.x);minPoint.y = Math.min(minPoint.y, point.y);minPoint.z = Math.min(minPoint.z, point.z);
      maxPoint.x = Math.max(maxPoint.x, point.x);maxPoint.y = Math.max(maxPoint.y, point.y);maxPoint.z = Math.max(maxPoint.z, point.z);
    }

    // Polygons
    var polys = [];
    for (var i = 0; i < npolys; i++) 
    {
      var retval = data.match(/(\d+ ?)+/);
      var str = retval[0];
      data = data.substr(str.length+1);
      
      var retval = str.match(/(\d+)/g);
      var nvertex = retval[0];

      polys.push(parseInt(retval[1]));
      polys.push(parseInt(retval[2]));
      polys.push(parseInt(retval[3]));
      if(nvertex == 4)
      {
	polys.push(parseInt(retval[1]));
	polys.push(parseInt(retval[3]));
	polys.push(parseInt(retval[4]));
      }
    }

    document.getElementById('fileinfo').innerHTML += ", polygons: "+npolys+", points: "+npoints;

    // Create model
    model = new Model(polys, vertices);

    // Return moving to center model
    return new point3D(-(maxPoint.x + minPoint.x)/2, -(maxPoint.y + minPoint.y)/2, -(maxPoint.z + minPoint.z)/2);
  }

  
  var PLYFile = 'monkey.ply';
  var fpsWanted = 24;
  var fps = [], fpslastUpdate;
  var fpsFilter = fpsWanted*2;
  function init()
  {
    document.getElementById('startButton').disabled = false;

    // Redefine model file
    var retval = document.location.search.match(/file=([\w\.]+)/);
    if(retval)
      PLYFile = retval[1];

    document.getElementById('fileinfo').innerHTML = "File: <a href='"+PLYFile+"'>"+PLYFile+"</a>";

    var canvas = document.getElementById("canvas");
    centerScreen = new point3D(canvas.width / 2, canvas.height / 2, 0);
    initWebGL(canvas);      // Initialize the GL context
    
    // Only continue if WebGL is available and working
    if (gl) {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);                      // Set clear color to black, fully opaque
      gl.enable(gl.DEPTH_TEST);                               // Enable depth testing
      gl.depthFunc(gl.LEQUAL);                                // Near things obscure far things
      gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // Clear the color as well as the depth buffer.
    }

    // Initialize the shaders; this is where all the lighting for the
    // vertices and so forth is established.
    
    initShaders();
    
    // Here's where we call the routine that builds all the objects
    // we'll be drawing.

    try {
      req = new XMLHttpRequest();
    } catch (e) {
      alert("Unsupported browser:\n" + e);
    }
    if (req) {
      // Try to get model
      req.open("GET", PLYFile, true);
      req.onreadystatechange = processReqChange;
      req.send(null);
    }
  }

  function initAfterGettingModel(data)
  {
    moveForCentering = ply_reader(data);
    
/*
    if(PLYFile == 'teapot.ply')
      model.rotate('x', -90 * Math.PI / 180);
*/
    drawScene();
  }

  function startRotating()
  {
    var radios = document.getElementsByName('fps');
    for (var index in radios)
      if(radios[index].checked == true)
	fpsWanted = radios[index].value;

    document.getElementById('startButton').disabled = true;
    document.getElementById('stopButton').disabled = false;
    if(typeof timer != "undefined")
      return;
    timer = setInterval(nextFrame, 1000 / fpsWanted);
  }
  function stopRotating()
  {
    document.getElementById('startButton').disabled = false;
    document.getElementById('stopButton').disabled = true;
    if(!timer)
      return;
    clearInterval(timer);
    timer = undefined;
    fps = [];
  }
  function changeFPS(input)
  {
    if(typeof timer != "undefined")
    {
      stopRotating();
      startRotating();
    }
  }
</script>

<style type="text/css">
  canvas { border: 0px solid black; }
</style>

<script id="shader-fs" type="x-shader/x-fragment">
  void main(void) 
  {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
 
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
   
  void main(void) 
  {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>

</head>


<body onload="init()">

<h1>PLY 3D model viewer based on HTML5 canvas on WebGL contex</h1>
<p>Features:
  <ul>
    <li>3D operations: rotating, moving object center</li>
    <li>Direct illumination</li>
  </ul>
</p>
<canvas id="canvas" width="400" height="225"></canvas>
<br>
<div id="fileinfo"></div>
<br>
Max allowed:
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="12"/>12 fps</label>
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="24" checked="checked"/>24 fps</label>
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="48"/>48 fps</label>
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="60"/>60 fps</label>
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="72"/>72 fps</label>
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="100"/>100 fps</label>
<label><input type="radio" name="fps" onclick="changeFPS(this)" value="120"/>120 fps</label>
<br>
<button id="startButton" onclick="startRotating()">Start Y rotating</button> <button id="stopButton" onclick="stopRotating()" disabled="disabled">Stop Y rotating</button>
</body>

</html>
